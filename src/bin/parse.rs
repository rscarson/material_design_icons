//! Regenerates `src/glyphs.rs` with the icon data from Google's Material Design Icons font
//!
//! This script will load the outlined, rounded, and sharp fonts
//!
use material_design_icons::font::{Font, FontError, FontMapper, Glyph};

const TARGET: &str = "src/glyphs.rs";

fn main() -> Result<(), FontError> {
    print!("Loading outlined font... ");
    let outlined = Font::new_outlined()?;
    print!("Generating code... ");
    let outlined = codegen_font("Outlined", &outlined)?;
    println!("Done!");

    print!("Loading rounded font... ");
    let rounded = Font::new_rounded()?;
    print!("Generating code... ");
    let rounded = codegen_font("Rounded", &rounded)?;
    println!("Done!");

    print!("Loading sharp font... ");
    let sharp = Font::new_sharp()?;
    print!("Generating code... ");
    let sharp = codegen_font("Sharp", &sharp)?;
    println!("Done!");

    print!("Finalizing code... ");
    let code = codegen_file(&[outlined, rounded, sharp]);
    print!("Writing to file... ");
    std::fs::write(TARGET, code)?;
    println!("Done!");
    Ok(())
}

/// Generate the code for the entire file
pub fn codegen_file(fonts: &[String]) -> String {
    const HEADERS: &[&str] = &[
        "//! Generated by `src/bin/parse.rs`",
        "//! Do not modify this file directly",
        "//!",
        "",
    ];

    let fonts = fonts.join("\n\n");
    [HEADERS.join("\n"), fonts].join("\n") + "\n"
}

/// Generate the code for a font
fn codegen_font(name: &str, font: &Font<'_>) -> Result<String, FontError> {
    const PREAMBLE: &[&str] = &[
        "/// List of Google's Material Design icon names and associated codepoints  ",
        "/// Go to [https://fonts.google.com/icons] to see the full list of icons",
        "#[derive(Debug, Clone, Copy)]",
        "#[repr(u32)]",
    ];

    let preamble = PREAMBLE.join("\n");
    let name = format!("pub enum {name} {{");

    let mapper = FontMapper::new(font)?;
    let glyphs = mapper.all_chars()?;

    let entries = glyphs
        .into_iter()
        .map(|glyph| {
            let comment = format!("    /// [Preview `{}`]({})", glyph.name, glyph.query_url());
            let code = format!("    {} = 0x{:0x},", glyph.identifier(), glyph.codepoint);

            [comment, code].join("\n")
        })
        .collect::<Vec<_>>()
        .join("\n\n");

    let suffix = "}".to_string();
    Ok([preamble, name, entries, suffix].join("\n"))
}

pub trait QueryExt {
    /// Get a URL for a preview of the selected icon
    fn query_url(&self) -> String;

    /// Get the glyph name as a SnakeCase identifier
    fn identifier(&self) -> String;
}
impl QueryExt for Glyph<'_> {
    fn query_url(&self) -> String {
        format!(
            "https://fonts.google.com/icons?icon.query={}",
            self.name.replace(" ", "%20")
        )
    }

    fn identifier(&self) -> String {
        let mut identifier = self.name.to_lowercase();
        identifier = identifier.replace('.', "");

        // First, replace all `_[a-z0-9]` with the uppercase variant
        let mut chars = identifier.chars();
        let mut result = String::new();
        while let Some(c) = chars.next() {
            if c == '_' {
                if let Some(next) = chars.next() {
                    result.push(next.to_uppercase().next().unwrap());
                }
            } else {
                result.push(c);
            }
        }
        identifier = result;

        // If we start with a number, add a leading underscore
        if identifier.chars().next().unwrap().is_numeric() {
            identifier = format!("_{}", identifier);
        }

        // Capitalize the first letter
        identifier = identifier
            .chars()
            .next()
            .unwrap()
            .to_uppercase()
            .collect::<String>()
            + &identifier[1..];

        identifier
    }
}
